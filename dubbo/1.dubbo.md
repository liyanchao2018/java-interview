



### **dubbo解决的问题:**

1. 怎么去维护url

​		通过注册中心去维护url (zookeeper、 redis、memcache--)

2. F5硬件负载均衡器的单点压力比较大

   软负载均衡

3. 怎么去整理出服务之间的依赖关系。

   自动去整理各个服务之间的依赖

4. 如果服务器的调用量越来越大，服务器的容量问题怎么去评估，扩容的指标

   需要一个监控平台，可以监控调用量、响应时间 



Dubbo是什么

dubbo是一个分布式的服务框架，提供高性能的以及透明化的RPC远程服务调用解决方法，以及SOA服务治理方案。



### Dubbo的核心部分:



	####  负载均衡算法：

**负载均衡的背景** 

​		到目前为止，dubbo 集成 zookeeper 解决了服务注册以及服务动态感知的问题。那么当服务端存在多个节点的集群时，zookeeper 上会维护不同集群节点，对于客户端而言，他需要一种负载均衡机制来实现目标服务的请求负载。通过负载均衡，可以让每个服务器节点获得适合自己处理能力的负载。负载均衡可以分为软件负载和硬件负载，在实际开发中，我们基础软件负载比较多，

比如 nginx，硬件负载现在用得比较少而且有专门的人来维护。

Dubbo 里面默认就集成了负载均衡的算法和实现，默认提供了 4 中负载均衡实现。

负载均衡算法有四种：

##### RandomLoadBalance:权重随机算法

​		权重随机算法，根据权重值进行随机负载。

​		它的算法思想很简单。假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为weights = [5, 3, 2]，权重总和为 10。

现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。

接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。

比如数字 3 会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例



##### LeastActiveLoadBalance:最少活跃调用数算法

​		最少活跃调用数算法，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求这个是比较科学的负载均衡算法。

​		每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。

​		在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求

##### ConsistentHashLoadBalance:hash 一致性算法

​		hash 一致性算法，相同参数的请求总是发到同一提供者，当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动

##### RoundRobinLoadBalance:加权轮询算法

​		加权轮询算法

​		所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。

​		我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。

​		轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每

台服务器的负载。

​		经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在 8 次请求中，服务器 A 将收到其中的 5 次请求，服务器 B 会收到其中的 2 次请求，服务器 C 则收到其中的 1次请求。



#### Dubbo 中负载均衡的应用

​		配置的属性名称：

​		roundrobin/random/leastactive/ consistenthash

~~~xml
<dubbo:service interface="..." loadbalance="roundrobin" />

<dubbo:reference interface="..." loadbalance="roundrobin" />
~~~



可以在服务端配置，也可以在客户端配置。

如果是基于注解，配置如下

~~~java
@Service(loadbalance = "roundrobin")
public class HelloServiceImpl implements IHelloService{

//或者

@Reference(loadbalance = "random")
IHelloService helloService;
~~~



#### 集群容错

​		在分布式网络通信中，容错能力是必须要具备的，什么叫容错呢？ 从字面意思来看：容：是容忍， 错：是错误。 就是容忍错误的能力。

​		我们知道网络通信会有很多不确定因素，比如网络延迟、网络中断、服务异常等，会造成当前这次请求出现失败。

当服务通信出现这个问题时，需要采取一定的措施应对。

​		而 dubbo 中提供了容错机制来优雅处理这种错误在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。

~~~java
@Service(loadbalance = "random", cluster = "failsafe") 
~~~



##### **Failover Cluster** 

​		失败自动切换，当出现失败，重试其它服务器。(缺省)

​		通常用于读操作，但重试会带来更长延迟。

​		可通过 retries="2" 来设置重试次数(不含第一次)。

##### Failfast Cluster

​		快速失败，只发起一次调用，失败立即报错。

​		通常用于非幂等性的写操作，比如新增记录。

##### Failsafe Cluster

​		失败安全，出现异常时，直接忽略。

​		通常用于写入审计日志等操作。

##### Failback Cluster

​		失败自动恢复，后台记录失败请求，定时重发。

​		通常用于消息通知操作。

##### Forking Cluster	

​		并行调用多个服务器，只要一个成功即返回。

​		通常用于实时性要求较高的读操作，但需要浪费更多服务资源。

​		可通过 forks="2" 来设置最大并行数。

##### Broadcast Cluster

​		广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0 开始支持)

​		通常用于通知所有提供者更新缓存或日志等本地资源信息。

​		在实际应用中 查询语句容错策略建议使用默认 Failover Cluster ，

而增删改 建议使用Failfast Cluster 或者 使用 Failover Cluster（retries=”0”） 策略 防止出现数据 重复添加等等其它问题！

建议在设计接口时候把查询接口方法单独做一个接口提供查询。



#### 服务降级

##### 降级的概念 

​		当某个非关键服务出现错误时，可以通过降级功能来临时屏蔽这个服务。

​		降级可以有几个层面的分类： 自动降级和人工降级； 

​		按照功能可以分为：读服务降级和写服务降级；

1. 对一些非核心服务进行人工降级，在大促之前通过降级开关关闭哪些推荐内容、评价等对主流程没有影响的功能

2. 故障降级，比如调用的远程服务挂了，网络故障、或者 RPC 服务返回异常。 那么可以直接降级，降级的方案比如设置默认值、采用兜底数据（系统推荐的行为广告挂了，可以提前准备静态页面做返回）等等

3. 限流降级，在秒杀这种流量比较集中并且流量特别大的情况下，因为突发访问量特别大可能会导致系统支撑不了。这个时候可以采用限流来限制访问量。当达到阀值时，后续的请求被降级，比如进入排队页面，比如跳转到错误页（活动太火爆，稍后重试等）



那么，Dubbo 中如何实现服务降级呢？Dubbo 中提供了一个 mock 的配置，可以通过mock 来实现当服务提供方出现网络异常或者挂掉以后，客户端不抛出异常，而是通过Mock 数据返回自定义的数据



##### Dubbo 实现服务降级 

​		在 dubbo-client 端创建一个 mock 类，当出现服务降级时，会被调用

~~~java
public class MockSayHelloService implements IHelloService {

 	@Override
 	public String sayHello() {
 		return "Sorry, 服务端发生异常，被降级啦！";
 	} 
}
~~~

​		修改客户端的注解，增加 mock 配置，以及修改 timeout=1， 表示本次调用的超时时间是 1 毫秒，这样可以模拟出失败的场景

需要配置 cluster=failfast，否则因为默认是 failover 导致客户端会发起 3 次重试，等待的时间比较长

~~~java
@Reference(

 loadbalance = "random", timeout =1000, cluster = "failfast",
    
 mock = "com.springboot.practice.springbootdubboclient.MockSayHelloService" )
 
IHelloService  helloService;
~~~



##### [dubbo是如何控制并发数和限流的](https://www.cnblogs.com/luozhiyun/p/10960593.html)

###### [ExecuteLimitFilter](https://www.cnblogs.com/luozhiyun/p/10960593.html#169118775)

​		ExecuteLimitFilter ，在服务提供者，通过 <dubbo:service /> 的 "executes" 

​		统一配置项开启：表示每服务的每方法最大可并行执行请求数。

~~~xml
<dubbo:service interface="com.manzhizhen.service.MyLoverService" executes="100" />
~~~



​		ExecuteLimitFilter是通过信号量来实现的对服务端的并发数的控制。

ExecuteLimitFilter执行流程：

1. 首先会去获得服务提供者每服务每方法最大可并行执行请求数
2. 如果每服务每方法最大可并行执行请求数大于零，那么就基于基于服务 URL + 方法维度获取一个RpcStatus实例
3. 通过RpcStatus实例获取一个信号量，若果获取的这个信号量调用tryAcquire返回false，则抛出异常
4. 如果没有抛异常，那么久调用RpcStatus静态方法beginCount，给这个 URL + 方法维度开始计数
5. 调用服务
6. 调用结束后计数调用RpcStatus静态方法endCount，计数结束
7. 释放信号量

 ExecuteLimitFilter

```java
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        URL url = invoker.getUrl();
        String methodName = invocation.getMethodName();
        Semaphore executesLimit = null;
        boolean acquireResult = false;
        int max = url.getMethodParameter(methodName, Constants.EXECUTES_KEY, 0);
        if (max > 0) {
            RpcStatus count = RpcStatus.getStatus(url, invocation.getMethodName());
//            if (count.getActive() >= max) {
            /**
             * http://manzhizhen.iteye.com/blog/2386408
             * use semaphore for concurrency control (to limit thread number)
             */
            executesLimit = count.getSemaphore(max);
            if(executesLimit != null && !(acquireResult = executesLimit.tryAcquire())) {
                throw new RpcException("Failed to invoke method " + invocation.getMethodName() + " in provider " + url + ", cause: The service using threads greater than <dubbo:service executes=\"" + max + "\" /> limited.");
            }
        }
        long begin = System.currentTimeMillis();
        boolean isSuccess = true;
        RpcStatus.beginCount(url, methodName);
        try {
            Result result = invoker.invoke(invocation);
            return result;
        } catch (Throwable t) {
            isSuccess = false;
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new RpcException("unexpected exception when ExecuteLimitFilter", t);
            }
        } finally {
            RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isSuccess);
            if(acquireResult) {
                executesLimit.release();
            }
        }
    }
```

我们接下来看看RpcStatus这个类

```java
    private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> METHOD_STATISTICS = new ConcurrentHashMap<String, ConcurrentMap<String, RpcStatus>>();
    
    public static RpcStatus getStatus(URL url, String methodName) {
        String uri = url.toIdentityString();
        ConcurrentMap<String, RpcStatus> map = METHOD_STATISTICS.get(uri);
        if (map == null) {
            METHOD_STATISTICS.putIfAbsent(uri, new ConcurrentHashMap<String, RpcStatus>());
            map = METHOD_STATISTICS.get(uri);
        }
        RpcStatus status = map.get(methodName);
        if (status == null) {
            map.putIfAbsent(methodName, new RpcStatus());
            status = map.get(methodName);
        }
        return status;
    }
```

这个方法很简单，大概就是给RpcStatus这个类里面的静态属性METHOD_STATISTICS里面设值。外层的map是以url为key，里层的map是以方法名为key。

```java
    private volatile int executesPermits;

    public Semaphore getSemaphore(int maxThreadNum) {
        if(maxThreadNum <= 0) {
            return null;
        }

        if (executesLimit == null || executesPermits != maxThreadNum) {
            synchronized (this) {
                if (executesLimit == null || executesPermits != maxThreadNum) {
                    executesLimit = new Semaphore(maxThreadNum);
                    executesPermits = maxThreadNum;
                }
            }
        }

        return executesLimit;
    }
```

这个方法是获取信号量，如果这个实例里面的信号量是空的，那么就添加一个，如果不是空的就返回。

###### [TPSLimiter](https://www.cnblogs.com/luozhiyun/p/10960593.html#3282926119)

TpsLimitFilter 过滤器，用于服务提供者中，提供限流的功能。

配置方式：

1. 通过 <dubbo:parameter key="tps" value="" /> 配置项，添加到 <dubbo:service /> 或 <dubbo:provider /> 或 <dubbo:protocol /> 中开启，例如：

```xml
<dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoServiceImpl" protocol="injvm" >
    
    <dubbo:parameter key="tps" value="100" />
    
</dubbo:service>
```

1. 通过 <dubbo:parameter key="tps.interval" value="" /> 配置项，设置 TPS 周期。

   ~~~xml
    <dubbo:parameter key="tps.interval" value="" />
   ~~~

   

[TPSLimiter源码分析](https://www.cnblogs.com/luozhiyun/p/10960593.html#2405410665)

TpsLimitFilter

```java
    private final TPSLimiter tpsLimiter = new DefaultTPSLimiter();
    
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {

        if (!tpsLimiter.isAllowable(invoker.getUrl(), invocation)) {
            throw new RpcException(
                    "Failed to invoke service " +
                            invoker.getInterface().getName() +
                            "." +
                            invocation.getMethodName() +
                            " because exceed max service tps.");
        }

        return invoker.invoke(invocation);
    }
```

invoke方法调用了DefaultTPSLimiter的isAllowable，我们进入到isAllowable方法看一下

DefaultTPSLimiter

```java
    private final ConcurrentMap<String, StatItem> stats
            = new ConcurrentHashMap<String, StatItem>();
    @Override
    public boolean isAllowable(URL url, Invocation invocation) {
        //获取tps这个参数设置的大小
        int rate = url.getParameter(Constants.TPS_LIMIT_RATE_KEY, -1);
        //获取tps.interval这个参数设置的大小，默认60秒
        long interval = url.getParameter(Constants.TPS_LIMIT_INTERVAL_KEY,
                Constants.DEFAULT_TPS_LIMIT_INTERVAL);
        String serviceKey = url.getServiceKey();
        if (rate > 0) {
            StatItem statItem = stats.get(serviceKey);
            if (statItem == null) {
                stats.putIfAbsent(serviceKey,
                        new StatItem(serviceKey, rate, interval));
                statItem = stats.get(serviceKey);
            }
            return statItem.isAllowable();
        } else {
            StatItem statItem = stats.get(serviceKey);
            if (statItem != null) {
                stats.remove(serviceKey);
            }
        }

        return true;
    }
```

若要限流，调用 StatItem#isAllowable(url, invocation) 方法，根据 TPS 限流规则判断是否限制此次调用。

StatItem

```java
    private long lastResetTime;

    private long interval;

    private AtomicInteger token;

    private int rate;

    public boolean isAllowable() {
        long now = System.currentTimeMillis();
         // 若到达下一个周期，恢复可用种子数，设置最后重置时间。
        if (now > lastResetTime + interval) {
            token.set(rate);// 回复可用种子数
            lastResetTime = now;// 最后重置时间
        }
        // CAS ，直到或得到一个种子，或者没有足够种子
        int value = token.get();
        boolean flag = false;
        while (value > 0 && !flag) {
            flag = token.compareAndSet(value, value - 1);
            value = token.get();
        }

        return flag;
    }
```







##### 启动时检查 

​		Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check="true"。

​		可以通过 check="false" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。

registry、reference、consumer 都可以配置 check 这个属性.

~~~java
@Reference(

 loadbalance = "random",

 mock = 

"com.springboot.practice.springbootdubboclient.MockSayHelloService",

 timeout =1000,

 cluster = "failfast",

 check=false)

IHelloService helloService;
~~~



##### **多版本支持** 

​		当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。

可以按照以下的步骤进行版本迁移：

1. 在低压力时间段，先升级一半提供者为新版本

2. 再将所有消费者升级为新版本

3. 然后将剩下的一半提供者升级为新版本



##### 主机绑定 

**默认的主机绑定方式**

1. 通过 LocalHost.getLocalHost()获取本机地址。

2. 如果是 127.*等 loopback（环路地址）地址，则扫描各网卡，获取网卡 IP。
   1. 如果是 springboot，修改配置：dubbo.protocol.host=””
   2. 如果注册地址获取不正确，可以通过在 dubbo.xml 中加入主机地址的配置

~~~xml
<dubbo:protocol host="205.182.23.201">
~~~



##### 缺省主机端口

dubbo: 20880

rmi: 1099

http: 80

hessian: 80

webservice: 80

memcached: 11211

redis: 6379





**Dubbo的架构**

​	核心角色

​			Provider

​			Consumer

​			Registry

​			Monitor

​			Container 