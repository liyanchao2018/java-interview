# MySQL联合索引最左匹配原则



> 原文链接：https://segmentfault.com/a/1190000015416513



## **前言**

之前在网上看到过很多关于mysql联合索引最左前缀匹配的文章，自以为就了解了其原理，最近面试时和面试官交流，发现遗漏了些东西，这里自己整理一下这方面的内容。

------

## **最左前缀匹配原则**

​		在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：
对列col1、列col2和列col3建一个联合索引

```mysql
KEY test_col1_col2_col3 on test(col1,col2,col3);
```

联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。

```mysql
SELECT * FROM test WHERE col1="1" AND clo2="2" AND clo4=|"4"
```

上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。

## **注意**

索引的字段可以是任意顺序的，如：

```mysql
SELECT * FROM test WHERE col1="1" AND clo2="2"

SELECT * FROM test WHERE col2="2" AND clo1="1"
```

这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。

有人会疑惑第二个查询语句不符合最左前缀匹配：首先可以肯定是两个查询语句都包含索引(col1,col2)中的col1、col2两个字段，只是顺序不一样，查询条件一样，最后所查询的结果肯定是一样的。既然结果是一样的，到底以何种顺序的查询方式最好呢？此时我们可以借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。

## **为什么要使用联合索引**

- **减少开销**。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！
- **覆盖索引**。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。
- **效率高**。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select *from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w*10%* 10% *10%=1w，效率提升可想而知！

## **引申**

对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;        是否能够触发索引？
大多数人都会说NO，实际上却是YES。
**原因**：

```mysql
EXPLAIN SELECT * FROM test WHERE col2="2";

EXPLAIN SELECT * FROM test WHERE col1="1";
```

观察上述两个explain结果中的type字段。查询中分别是：

1. type: index
2. type: ref

**index**：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个**联合索引的一部分**，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。
**ref**：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，**也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。**

**附：**

## **个人总结资料，如转载请注明出处！**

参考文献：
[https://www.zhihu.com/questio...](https://www.zhihu.com/question/36996520)
[https://segmentfault.com/q/10...](https://segmentfault.com/q/1010000000342176)
[https://github.com/phpforlan/...](https://github.com/phpforlan/ArtisanPHP/issues/10)

 

在最左匹配原则中，有如下说明：

1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式









# [mysql联合索引的生效规则](https://www.cnblogs.com/mintsd/p/13062308.html)

mysql中 myisam，innodb默认使用的是 Btree索引，至于btree的数据结构是怎样的都不重要，
只需要知道结果，既然是索引那这个数据结构最后是排好序；就像新华字典他的目录就是按照a,b,c..这样排好序的；
所以你在找东西的时候才快，比如你找 “中” 这个字的解释，你肯定就会定位到目录的 z 开头部分；

组合索引可以这样理解，比如（a,b,c），abc都是排好序的，在任意一段a的下面b都是排好序的，任何一段b下面c都是排好序的；

<img src="..\mysql\images\713671-20170223142607007-29450957.png" alt="img" style="zoom:50%;" />

组合索引的生效原则是 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；
比如

```sql
where a=3 and b=45 and c=5 .... 这种三个索引顺序使用中间没有断点，全部发挥作用；
where a=3 and c=5... 这种情况下b就是断点，a发挥了效果，c没有效果
where b=3 and c=4... 这种情况下a就是断点，在a后面的索引都没有发挥作用，这种写法联合索引没有发挥任何效果；
where b=45 and a=3 and c=5 .... 这个跟第一个一样，全部发挥作用，abc只要用上了就行，跟写的顺序无关
```

（a,b,c） 三个列上加了联合索引（是联合索引 不是在每个列上单独加索引）

还需注意， (a,b,c)多列索引和 (a,c,b)是不一样的，看上面的图也看得出来关系顺序是不一样的；
分析几个实际例子来加强理解；
分析句子中使用的索引情况

```sql
(0)    select * from mytable where a=3 and b=5 and c=4;
abc三个索引都在where条件里面用到了，而且都发挥了作用
(1)    select * from mytable where  c=4 and b=6 and a=3;
这条语句列出来只想说明 mysql没有那么笨，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样
(2)    select * from mytable where a=3 and c=7;
a用到索引，b没有用，所以c是没有用到索引效果的
(3)    select * from mytable where a=3 and b>7 and c=3;
a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引
(4)    select * from mytable where b=3 and c=4;
因为a索引没有使用，所以这里 bc都没有用上索引效果
(5)    select * from mytable where a>4 and b=7 and c=9;
a用到了  b没有使用，c没有使用
(6)    select * from mytable where a=3 order by b;
a用到了索引，b在结果排序中也用到了索引的效果，前面说了，a下面任意一段的b是排好序的
(7)    select * from mytable where a=3 order by c;
a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort
(8)    select * from mytable where b=3 order by a;
b没有用到索引，排序中a也没有发挥索引效果
```

快速生成1000W测试数据库,创建测试表：

```sql
CREATE TABLE `merchant` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '商户号',
  `name` varchar(64) NOT NULL COMMENT '商户名称',
  `address` varchar(128) DEFAULT NULL COMMENT '商户地址',
  `accountNo` varchar(32) DEFAULT NULL COMMENT '账号',
  `accountName` varchar(128) DEFAULT NULL COMMENT '户名',
  `state` char(1) DEFAULT '1' COMMENT '商户状态 1激活 0关闭',
  PRIMARY KEY (`id`),
  KEY `name_address_accountNo_account_Name` (`name`,`address`,`accountNo`,`accountName`)
) ENGINE=InnoDB AUTO_INCREMENT=276711985 DEFAULT CHARSET=utf8;
```

编写存储过程:

```sql
delimiter $$
SET AUTOCOMMIT = 0$$
 
create  procedure merchant_pro()
begin
declare v_cnt decimal (10)  default 0 ;
dd:loop
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
insert  into merchant values( (select substring((select rand()*1000000000000) , 1,11)) ,'李岩超',
(SELECT CONCAT('北京市海淀区海淀五路居', (select substring((select rand()*10), 1,1)) )),
'No0000000','程序猿',0);
      commit;
        set v_cnt = v_cnt+10 ;
           if  v_cnt = 10000000 then leave dd;
          end if;
         end loop dd ;
end;$$

delimiter ;
```

调用存储过程：

```sql
call merchant_pro();
```



# 问题待解答

遇到了个问题，id生命11位int，但是插入时，id给11位数字 却存不上，不知是不是和有两位的保留有关系？