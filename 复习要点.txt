先介绍了下合同是和外包公司签，能不能接受，
	后面问你分布式事务，
	消息队列集群，
	然后其他的人问你具体业务场景，具体操作，
	后面几个人基本是外包人员，说话比较吵。
	对了腾讯会议面试，让你开视频，他们不开，我就不知道他们的平等在哪，外包岗位，加班多，大家慎重。



1.数据库索引
	explain sql
	type：system（表中只有一条数据）/const（主键或唯一索引）/eq_ref两表主键关联/ref/

2.redis主从模式 / redis集群模式  哨兵用在哪种模式下  
	redis集群分片原理
	redis数据结构与应用场景
	redis雪崩/redis击穿场景及如何避免
	
3.ReentrantLock锁机制
4.synchronize锁

5.zookeeper的Curator客户端支持哪些重试策略
	[client在网络抖动中，与zk失去连接，zk的哪些重试策略保证了client对于已经活得的锁因为网络抖动与zk断开连接，导致client2去获的了锁，失去了同一时间只有一个线程得到锁的意义]
	重试机制的处理逻辑主要在RetryLoop中，该类定义了重试所需要的属性，isDone 用于该重试是否还继续，retryCount 重试次数，RetryPolicy 重试策略，
	
	Curator内部实现的几种重试策略: 
	
	1）ExponentialBackoffRetry:重试指定的次数, 且每一次重试之间停顿的时间逐渐增加.

	 2）RetryNTimes:指定最大重试次数的重试策略

	 3）RetryOneTime:仅重试一次

	 4）RetryUntilElapsed:一直重试直到达到规定的时间
	 
	 

6.1为什么使用RabbitMQ
	RabbitMQ基于AMQP协议来实现。AMQP的主要特征是面向消息/队列/路由（包括点对点和发布/订阅）/可靠性安全。
	AMQP协议更多用在企业系统内，对数据一致性，稳定性，和可靠性要求很高的场景。
6.2RabbitMQ如何保证消息的准确传递：
	1.开启消息确认机制（消息发送方）
	2.队列持久化/消息（MQ发送到队列后，服务器宕机）
	3.消费者手动确认消息（消费者消费了消息，但是还未处理业务，就出现了异常。）
		spring: rabbitmq: listener: simple: # 手动签收模式 acknowledge-mode: manual # 每次签收一条消息 prefetch: 1
		
6.3MQ有几种模式：
	1.简单模式（生产者1 队列1 消费者1）
	2.工作模式（生产者1 队列1 消费者多个）
	3.发布/订阅模式，属于一种推模式push（1生产者 交换机 队列 2消费者 消费者分别绑定不同的队列）
	4.路由模式      （生产者  交换机 路由键 队列 消费者）
	5.通配符模式  （*表示匹配一个单词；#匹配0个或多个单词）
	
6.4消息使用的是哪种模式：
	发布/订阅模式，属于一种推模式push
6.5RabbitMQ集群使用的哪种模式：
	镜像模式：
		镜像模式也被叫做是Mirror镜像模式，它是现企业中比较常用的模式，它能够保证100%数据不丢失。
		主要的目的是在于保证数据的高可靠性。
		Rabbitmq现提供队列mirror功能，通过这一功能可以提高Rabbitmq的可靠性，当某个Rabbitmq节点故障时，只要其它节点里存在该故障节点的队列镜像，该队列就能继续正常工作不会丢失数据。
		HA配置是通过队列mirror功能实现的。在主节点（rabbit1）中执行如下命令，即可实现高可用状态
6.6RabbitMQ集群模式有几种?
	一、远程模式
		(1)、远程模式能够实现双活的一种模式，又被叫做Shovel模式，它可以将消息进行不同数据中心的复制工作，能够跨地域的让两个MQ集群互联。	
		当本地处理负载任务过高时，可以分担一些到异地集群中进行处理。
	二、主备模式	
		(1)主备模式是用在并发和数据量不高的情况下。在主节点宕机的时候，备用节点会充当主节点的角色提供服务。
		(2)主备模式和主从模式的区别？
			主备模式，读写都在主节点上；
			主从模式，写在主节点，读在备节点上。
		(3)RabbitMQ是通过HaProxy来路由可用的RabbitMQ服务的。
	三、多活模式
		(1)、因为远程模式配置太复杂，使用多活模式
			不论是双活又或者是多活都能够达到需求。
			多活模式要依赖rabbitmq的federation插件，能够实现持续可靠的AMQP通信，并且，配置和远程模式(Shovel)比较起来会更加的简单
	四、镜像模式
		镜像模式也被叫做是Mirror镜像模式，它是现企业中比较常用的模式，它能够保证100%数据不丢失。
		主要的目的是在于保证数据的高可靠性。
		Rabbitmq现提供队列mirror功能，通过这一功能可以提高Rabbitmq的可靠性，当某个Rabbitmq节点故障时，只要其它节点里存在该故障节点的队列镜像，该队列就能继续正常工作不会丢失数据。
		HA配置是通过队列mirror功能实现的。在主节点（rabbit1）中执行如下命令，即可实现高可用状态
		
6.7RabiltMQ怎样会产生死信

6.8RabiltMQ中dlx死信队列的消息如何再次推送给原有消费者




		
		
7.JVM
	7.1JVM结构
		jvm的内部结构如下图所示，这张图很清楚形象的描绘了整个JVM的内部结构，以及各个部分之间的交互和作用。
 
		1.Class Loader（类加载器）就是将Class文件加载到内存，再说的详细一点就是，把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是类加载器的作用。
		2.Run Data Area（运行时数据区） 就是我们常说的JVM管理的内存了，也是我们这里主要讨论的部分。运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行。这部分也是我们这里将要讨论的重点。
		3.Execution engine（执行引擎） 是Java虚拟机最核心的组成部分之一。执行引擎用于执行指令，不同的java虚拟机内部实现中，执行引擎在执行Java代码的时候可能有解释执行（解释器执行）和编译执行（通过即时编译器产生本地代码执行，例如BEA JRockit），也有可能两者兼备。任何JVM specification实现(JDK)的核心都是Execution engine，不同的JDK例如Sun 的JDK 和IBM的JDK好坏主要就取决于他们各自实现的Execution engine的好坏。
		4.Native interface 与native libraries交互，是其它编程语言交互的接口。当调用native方法的时候，就进入了一个全新的并且不再受虚拟机限制的世界，所以也很容易出现JVM无法控制的native heap OutOfMemory。

	7.2 Run Data Area（运行时数据区） 
		•Program Counter Register
			–程序计数器，线程私有、指向下一条要很执行的指令
		•Java Stack
			–Java虚拟机栈，线程私有，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口
		•Native Method Stack
			–为虚拟机使用到的Native 方法服务
		•Heap
			–线程共享，由于现在收集器基本采用的分代收集算法，所以Java堆中还可以细分：新生代和老生代；更细致一点的有Eden空间、From Survivor空间、To Survivor空间等。所有的对象实例以及数组都要在堆上分配，是垃圾收集器管理的主要区域
		•Method Area
			–方法区，别名叫做非堆(Non-Heap)，线程共享的内存区域。目的是与Java堆区分开来，存储类信息、常量、静态变量、即时编译器编译后的代码。 方法区存放的信息包括：
		•A 类的基本信息：
			–1.每个类的全限定名 
			–2.每个类的直接超类的全限定名(可约束类型转换)
			–3.该类是类还是接口
			–4.该类型的访问修饰符 
			–5.直接超接口的全限定名的有序列表
		•B 已装载类的详细信息 
			–1.运行时常量池：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。它们以数组形式通过索引被访 问，是外部调用与类联系及类型对象化的桥梁。（存的可能是个普通的字符串，然后经过常量池解析，则变成指向某个类的引用） 
			–2.字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。字段名称指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符。
			–3.方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。) 
			–4.静态变量：就是类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块。 
			–5.到类classloader的引用：到该类的类装载器的引用。 6.到类class 的引用：jvm为每个加载的类型(译者：包括类和接口)都创建一个java.lang.Class的实例。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来。
				
	7.3JMM
		Java内存模型(Java Memory Model，JMM)JMM主要是为了规定了线程和内存之间的一些关系。根据JMM的设计，系统存在一个主内存(Main Memory)，Java中所有变量都储存在主存中，对于所有线程都是共享的。每条线程都有自己的工作内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。

8.JVM垃圾回收机制
	8.1.什么是垃圾回收机制
		垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。
	8.2.什么时候进行垃圾回收
		①会在cpu空闲的时候自动进行回收 　
		②在堆内存存储满了之后 　
		③主动调用System.gc()后尝试进行回收
		补充：System.gc()用于调用垃圾收集器，在调用时，垃圾收集器将运行以回收未使用的内存空间。它将尝试释放被丢弃对象占用的内存。 然而System.gc（）调用附带一个免责声明，无法保证对垃圾收集器的调用。 　所以System.gc()并不能说是完美主动进了垃圾回收。
	8.3.如何判断对象已死（或能够被回收）
		①引用计数法
		    简单的来说就是判断对象的引用数量。
		    实现方式：给对象共添加一个引用计数器，每当有引用对他进行引用时，计数器的值就加1，当引用失效，也就是不在执行此对象，它的计数器的值随之减1，若某一个对象的计数器的值为0，那么表示这个对象没有被其他对象引用，也就是意味着是一个失效的垃圾对象，就会被gc进行回收。 
		    但是这种简单的算法在当前的jvm中并没有采用，原因是他并不能解决对象之间循环引用的问题。 假设有A和B两个对象之间互相引用，也就是说A对象中的一个属性是B，B中的一个属性时A,这种情况下由于他们的相互引用，从而垃圾回收机制无法识别。
		②可达性分析算法（根搜索算法）
		    通过一系列名为GC Roots的对象作为起点，从这些节点往下搜索，搜索走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时（意味着GC Roots到这个对象不可达），证明该对象是不可用的，则应该被回收

	8.4.垃圾回收算法的种类
		4.1 按照方法分类：
		①标记-清理算法
		分为两个步骤：
		第一就是标记，也就是标记所有的需要回收的对象；
		第二就是清理，标记完成后进行统一的回收带有标记的对象占据的内存空间。缺点是效率问题，还有一个致命的缺点就是空间问题，标记清除之后会产生大量不连续的内存碎片，当程序在运行过程中需要分配较大对象时，无法找到足够的连续内存而造成内存空间浪费。 
		②复制算法
		   复制算法是将内存容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完之后，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次性清理。这样使得每次都对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只是这种算法的代价就是将内存缩小为原来的一半了。

		③标记-整理算法
		标记整理算法与标记清除算法很相似，但显著的区别是：标记清除算法仅对不存活的对象进行处理，剩余存活对象不做任何处理，这就造成了内存碎片的问题；而标记整理算法不仅对不存活的对象进行清除，还对存活的对象进行重新整理，因此不会产生内存不连续的现象。

		4.2 按照回收策略分类
		分代收集算法
		   分代收集算法是一种比较智能的算法，也是现在jvm使用最多的一种算法，它本身其实不是一个新的算法，而是他会在具体的场景自动选择以上三种算法进行垃圾对象回收。在jdk1.7之前，对JVM分为三个区域：新生代、老年代、永久代
		4.2.1 ①新生代
		新生代的目标就是尽可能快速的收集掉那些生命周期较短的对象，一般情况下新生成的或者朝生夕亡的对象一般都是首先存放在新生代里面。

		新生代将内存按照8:1:1分为一个Eden和so，s1三个区域；，因为对象生命周期不一样，所以产生了分代。
		新生代：老年代=1：2
		当新生代沾满时，老年代会作为一个 分配担保，保存到老年代。
		大部分对象都在Eden区域生成，在垃圾回收时，先将Eden存活的对象复制到s0区，然后清除Eden区，当这个s0区满了，则将Eden区和s0区的存活对象复制到s1，然后将Eden和s0区清空，此时s0是空的，然后交换s0和s1的角色（即下次回收会扫描eden和s1区），即保持s0为空，如此往复；特别地，当s1不足以存放Eden和s0存放的对象时，则将对象直接放到老年代）
		适用回收算法：复制算法
		在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成垃圾收集
		4.2.2 ②老年代
		老年代一般存放的是一些生命周期较长的对象，比如在新生代中经历来了n次垃圾回收后仍然存活的对象都进入了老年代。
		适用回收算法：标记整理或标记清除
		在老年代中因为对象存活率较高，没有额外的空间对它分配担保，就必须使用标记清除或标记整理
		4.2.3 ③永久代
		永久代主要存放静态文件，如java类，方法等，永久代对垃圾回收没有显著影响。

		jdk1.8之前与之后的jmm结构
	
	
	8.5垃圾收集器
	 如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
	上面说过，各个平台虚拟机对内存的操作各不相同，因此本章所讲的收集器是基于JDK1.7Update14之后的HotSpot虚拟机。这个虚拟机包含的所有收集器如图：
	 
	其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。
	1、Serial收集器（复制算法)
	 新生代单线程收集器，优点是简单高效。Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。
	 大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
	 
	2、ParNew收集器 (复制算法)
	 新生代并行收集器，ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。
	  
	3、Parallel Scavenge收集器(复制算法)
	新生代并行收集器，追求高吞吐量，高效利用 CPU。


	Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。
	4、Serial Old收集器(标记-整理算法)
	 老年代单线程收集器，Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另一种用途就是作为CMS收集器的后备预案，在并发收集发生ConcurrentMode Failure时使用。
	5、Parallel Old收集器 (标记-整理算法)
	老年代并行收集器，吞吐量优先
	Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的。
	6、CMS收集器（标记-清除算法）
	老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。


	 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
	 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 
	运作过程分为4个步骤，包括： 
	a)初始标记（CMS initial mark） 
	b)并发标记（CMS concurrent mark） 
	c)重新标记（CMS remark） 
	d)并发清除（CMS concurrent sweep）
	CMS收集器存在3个缺点： 
	1 对CPU资源敏感。一般并发执行的程序对CPU数量都是比较敏感的 
	2 无法处理浮动垃圾。在并发清理阶段用户线程还在执行，这时产生的垃圾无法清理。 
	3 由于标记-清除算法产生大量的空间碎片。
	7、G1收集器 (标记-整理算法)
	 Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。


	G1是一款面向服务端应用的垃圾收集器。 
	G1收集器的运作大致可划分为以下几个步骤：
	a)初始标记（Initial Marking） 
	b)并发标记（Concurrent Marking） 
	c)最终标记（Final Marking） 
	d)筛选回收（Live Data Counting and Evacuation）

							
		
		
		
		
		
		