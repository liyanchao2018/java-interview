## MYSQL 事务/事务ACID特性/事务隔离级别/锁/MVCC

### 1.事务

#### 1.1什么是事务:

> 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作； 
>
> 事务是一组不可再分割的操作集合（工作逻辑单元）;

#### 1.2典型事务场景(转账)：

~~~sql
update user_account set balance = balance - 1000 where userID = 3; 
update user_account set balance = balance +1000 where userID = 1;
~~~

#### 1.3mysql中如何开启事务：

~~~sql
begin / start transaction       -- 手工 
commit / rollback                  -- 事务提交或回滚 
set session autocommit = on/off; -- 设定事务是否自动开启
~~~

#### 1.4mysql默认事务级别为：自动提交

> ~~~sql
>select VARIABLES like 'autocommit';
> ~~~
> 
> 结果为：on，表示自动提交。

#### 1.5JDBC 编程：

 connection.setAutoCommit（boolean）;

#### 1.6Spring 事务AOP编程：

expression=execution（com.gpedu.dao.*.*(..)）



### 2.事务ACID特性

> * 原子性（Atomicity） 
>   * 最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚
> * 一致性（Consistency）
>   * 事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则，       不会因为出现系统意外等原因导致状态的不一致
> * 隔离性（Isolation）
>   * 一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）
>     持久性（Durability） 事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失



### 3.事务隔离级别

[SQL92 ANSI/ISO标准：]( http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt)

事务隔离界别：

* Read Uncommitted（未提交读） --未解决并发问题 

​			事务未提交对其他事务也是可见的，脏读（dirty read）

* Read Committed（提交读） --解决脏读问题 

​			一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）

* Repeatable Read (可重复读) --解决不可重复读问题 

​			在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题

* Serializable（串行化） --解决所有问题 

​			最高的隔离级别，通过强制事务的串行执行



> 事务并发带来了哪些问题

#### 3.1 Read Uncommitted（未提交读） 

**图一**

![image-20200416202719321](D:\data\typora-images\image-20200416202719321.png)

> **<u>事务B先update，接着事务A select ，然后事务B roolaback。事务A产生脏读现象。</u>**

**解决：**

> **<u>通过将事务隔离级别【Read Uncommitted(为提交读)】 --> Read Committed（提交读），即可解决图一的问题。</u>**



#### 3.2Read Committed（提交读） 

**图二**

![image-20200416202825574](D:\data\typora-images\image-20200416202825574.png)

> **<u>事务A先select，接着事务B update ，然后事务B commit，然后事务A select。事务A在一次开启事务的过程中，两次查询，得到两次不同的数据，产生 可重复度 的问题。</u>**

**解决：**

> **<u>通过将事务隔离级别 ：Read Committed（提交读） --> Repeatable Read (可重复读) </u>**
>
> **<u>即可解决图二的问题。</u>**



#### 3.3Repeatable Read (可重复读) 

> 图三

![image-20200416202845472](D:\data\typora-images\image-20200416202845472.png)

> **<u>事务A先select，接着事务B insert  但未commit，然后事务A select。事务A在一次开启事务的过程中，两次查询的结果集不同，产生 幻读 的问题。</u>**

**解决：**

> **<u>通过将事务隔离级别 ： Repeatable Read (可重复读) -->Serializable（串行化） </u>**
>
> **<u>即可解决图三的问题。</u>**



#### 3.4 InnoDB引擎对隔离级别的支持程度

> 事务隔离级别的并发能力由串行化-->未提交读 越来越高

![image-20200416204418266](D:\data\typora-images\image-20200416204418266.png)



### 4.锁

> 锁是用于管理不同事务对共享资源的并发访问

**表锁与行锁的区别：**   

> 锁定粒度：表锁 > 行锁 
>
> 加锁效率：表锁 > 行锁 
>
> 冲突概率：表锁 > 行锁 
>
> 并发性能：表锁 < 行锁

#### 4.1[MySQL InnoDB锁类型]( https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html )

* 共享锁（行锁）：Shared Locks 
* 排它锁（行锁）：Exclusive Locks 
* 意向锁共享锁（表锁）：Intention Shared  Locks 
* 意向锁排它锁（表锁）：Intention Exclusive Locks 
* 自增锁：AUTO-INC Locks 

**行锁的算法**

* 记录锁 Record Locks 
* 间隙锁 Gap Locks 
* 临键锁 Next-key Locks 行锁的算法
  

##### 4.1.1 共享锁（Shared Locks）vs 排它锁（Exclusive Lock）

**共享锁:**

> * 又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁， 都能访问到数据，但是只能读不能修改;
>
> * 加锁释锁方式：
>   *  select * from users WHERE id=1 LOCK IN SHARE MODE; 
>   * commit/rollback

**排他锁:**

> * 又称为写锁，简称X锁，排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁（共享锁、排他锁），只有该获取了排他锁的事务是可以对 数据行进行读取和修改，（其他事务要读取数据可来自于快照）

`排它锁，不影响另一个事务的select * from table 。但影响另一个事务的操作： delete / update / insert /SELECT * FROM table_name WHERE ... FOR UPDATE  ，不能同时执行。` 

**加锁释放锁方式：** 

> delete / update / insert 默认加上X锁 
>
> SELECT * FROM table_name WHERE ... FOR UPDATE  也相当于加上X锁 
>
> commit/rollback

 **InnoDB 行锁到底锁了什么**

* <u>**InnoDB的行锁是通过给索引上的索引项加锁来实现的。**</u>
* **只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）（另类的行锁）**

<u>如上述两点，我们在删除/修改数据时，一定要让where条件命中我们的索引，否则，会锁表，影响别的事务对此表的操作。</u>

​       **表锁：lock tables xx read/write；**



##### 4.1.2意向锁共享锁（IS）&意向锁排它锁（IX）

> **意向锁(IS、IX) 是（表锁）**

* 意向共享锁(IS) 
  * 表示事务准备给数据行加入共享锁，即一个数据行加共享锁前必须先取得该表的IS锁， 意向共享锁之间是可以相互兼容的
* 意向排它锁(IX) 
  * 表示事务准备给数据行加入排他锁，即一个数据行加排他锁前必须先取得该表的IX锁， 意向排它锁之间是可以相互兼容的

> 意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预。

**意向锁(IS、IX)意义：**

> 当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则 可快速返回该表不能 启用表锁



##### 4.1.3自增锁AUTO-INC Locks

针对自增列自增长的一个特殊的表级别锁

~~~sql
show variables like  'innodb_autoinc_lock_mode';
~~~

默认取值1，代表连续，事务未提交ID永久丢失。



##### 4.1.4记录锁（Record）&间隙锁（Gap）&临建锁（Next-key）

* **Next-key locks：** 

  * 锁住记录+区间（左开右闭）

  当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、<、>等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，锁住索引的记录+区间（左开右闭）

* **Gap locks：** 

  * 锁住数据不存在的区间（左开右开）

  当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，锁住索引不存在的区间（左开右开）

* **Record locks：**

  *  锁住具体的索引项

  当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，锁住具体的索引项



##### 4.1.5临建锁（Next-key）

![image-20200416212413378](D:\data\typora-images\image-20200416212413378.png)

> 临建锁 大致含义：
>
> 将表数据



##### 4.1.6间隙锁（Gap）

![image-20200416212730549](D:\data\typora-images\image-20200416212730549.png)





##### 4.1.7记录锁（Record）

![image-20200416212744720](D:\data\typora-images\image-20200416212744720.png)





#### 4.2利用锁怎么解决不可重复读

![image-20200416212848536](D:\data\typora-images\image-20200416212848536.png)



#### 4.3利用锁怎么解决幻读

![image-20200416212921387](D:\data\typora-images\image-20200416212921387.png)



#### 4.4死锁介绍

* 多个并发事务（2个或者以上）；
* 每个事务都持有锁（或者是已经在等待锁）;
* 每个事务都需要再继续持有锁；
* 事务之间产生加锁的循环等待，形成死锁。

#### 4.5 死锁避免

* 1）类似的业务逻辑以固定的顺序访问表和行。
* 2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。 
* 3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概 率。 
* 4）降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择 
* 5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）

#### 4.6 思考引申出MVCC

![image-20200416213340621](D:\data\typora-images\image-20200416213340621.png)

